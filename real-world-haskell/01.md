# Chapter 1: Getting Started. Abstract

The most popular Haskell implementation is Glasgow Haskell Compiler (GHC).
It has 3 main components:

`ghc` - the compiler, `ghci` - REPL, `runghc` - script runner.

## Run GHCi

```bash
$ ghci
GHCi, version 8.6.5: http://www.haskell.org/ghc/  :? for help
Prelude>
```

## GHCi as calculator

### Basic arithmetic

1. You can use basic arithmetic operations: +, -, *, /, ^.
2. Be careful with unary -.
3. Wrap negative literals with () if using in expressions.

```haskell
Prelude> 3 ^ 20 -- <1>
3486784401
Prelude> 1 + -1 -- <2>
<interactive>:8:1: error:
    Precedence parsing error
        cannot mix ‘+’ [infixl 6] and prefix `-' [infixl 6] in the same infix expression
Prelude> 1 + (-1) -- <3>
0
Prelude> 2 * -3 -- <2>
<interactive>:10:1: error:
    Precedence parsing error
        cannot mix ‘*’ [infixl 7] and prefix `-' [infixl 6] in the same infix expression
Prelude> 2 * (-3) -- <3>
-6
```

### Boolean logic

1. Haskell has Boolean arithmetic as well (syntax is regular).
2. Strong

```haskell
ghci> True && False -- <1>
False
ghci> False || True -- <1>
True
ghci> True && 1 -- <2>

<interactive>:11:9: error:
    • No instance for (Num Bool) arising from the literal ‘1’
    • In the second argument of ‘(&&)’, namely ‘1’
      In the expression: True && 1
      In an equation for ‘it’: it = True && 1
```

### Comparing numbers

1. Comparing in Haskell is regular
2. Except for Not Equal operator, it is written as / and = together.

```haskell
Prelude> 1 == 1 -- <1>
True
Prelude> 3 > 2 -- <1>
True
Prelude> 4 >= 3.99 -- <1>
True
Prelude> 2 /= 3 -- <2>
True
Prelude> 2 /= 2 -- <2>
False
```

## Operator precedence and associativity

1 is the lowest precedence and 9 is the highest.
Get info using `:info` in GHCi.

The last lines of outputs ("infixl 6 +" and "infixl 7 *")
describe that operators are infix (written between operands),
left associative (calculated from left to right),
have precedence of 6 and 7 respectively (e. g. * calculated before +).

```haskell
Prelude> :info (+)
class Num a where
  (+) :: a -> a -> a
  ...
        -- Defined in ‘GHC.Num’
infixl 6 +
Prelude> :info (*)
class Num a where
  ...
  (*) :: a -> a -> a
  ...
        -- Defined in ‘GHC.Num’
infixl 7 *
Prelude>
```

## Variables

Define a variable in GHCi.

```haskell
Prelude> e

<interactive>:1:1: error: Variable not in scope: e
Prelude> e = exp 1
Prelude> e
2.718281828459045
```

## Lists

Lists are created with `[]`. Lists can contain values only of one type.

```haskell
Prelude> [1, 2, 3]
[1,2,3]
Prelude> []
[]
Prelude> ["foo", "bar", "baz"]
["foo","bar","baz"]
Prelude> [True, 1, "foo"]

<interactive>:7:11: error:
    • Couldn't match expected type ‘Bool’ with actual type ‘[Char]’
    • In the expression: "foo"
      In the expression: [True, 1, "foo"]
      In an equation for ‘it’: it = [True, 1, "foo"]
```

Enumeration notation:

```haskell
Prelude> [1..12]
[1,2,3,4,5,6,7,8,9,10,11,12]
Prelude> [1,3..12]
[1,3,5,7,9,11]
Prelude> [1.0,1.5..6.0]
[1.0,1.5,2.0,2.5,3.0,3.5,4.0,4.5,5.0,5.5,6.0]
Prelude> [7..1]
[]
Prelude> [7,6..1]
[7,6,5,4,3,2,1]
```

List operations:

```haskell
Prelude> [1] ++ [2, 3, 4] ++ [5] -- lists concatenation
[1,2,3,4,5]
Prelude> 1 : [2, 3, 4] -- "cons" - prepend to list
[1,2,3,4]
```

Strings:

Strings in Haskell are lists of characters.

```haskell
Prelude> ['a', 'b', 'c', 'd'] -- list of chars
"abcd"
Prelude> ['a', 'b', 'c', 'd'] == "abcd" -- they are equal
True
Prelude> [] == "" -- empty string is empty list
True
Prelude> 'a' : "bcd" -- prepend to a string as to a list
"abcd"
Prelude> "ab" ++ "cd" -- concat like lists
"abcd"
Prelude> :set +t -- print types of expressions
Prelude> 'c'
'c'
it :: Char
Prelude> "abc"
"abc"
it :: [Char] -- list of chars
```

## Other stuff

Load module to GHCi using `:m +...`

```haskell
Prelude> :m +Data.Ratio
Prelude Data.Ratio> 11 % 29
11 % 29
it :: Integral a => Ratio a
```

With `unset +t` types won't be printed.
To find out type of an expression use `:type`.

```haskell
Prelude> :unset +t
Prelude> 3
3
Prelude> :type 3
3 :: Num p => p
Prelude> :type ""
"" :: [Char]
```

## First program

Save the program to file `WC.hs`.

```haskell
main = interact wordCount
    where wordCount input = show (length (lines input)) ++ "\n"
```

Run it using `runghc`. Enter some string, submit by pressing `^D`.

```bash
$ runghc WC.hs
Apple
Orange
Grape
Banana
Melon
5
$
```

## Exercises

1. Enter the following expressions into `GHCi`. What are their types?

  - 5 + 8
  - 3 * 5 + 8
  - 2 + 4
  - (+) 2 4
  - sqrt 16
  - succ 6
  - succ 7
  - pred 9
  - pred 8
  - sin (pi / 2)
  - truncate pi
  - round 3.5
  - round 3.4
  - floor 3.7
  - ceiling 3.3

```haskell
Prelude> 5 + 8
13
Prelude> :set +t
Prelude>
Prelude> 5 + 8
13
it :: Num a => a
Prelude> 3 * 5 + 8
23
it :: Num a => a
Prelude> 2 + 4
6
it :: Num a => a
Prelude> (+) 2 4
6
it :: Num a => a
Prelude> sqrt 16
4.0
it :: Floating a => a
Prelude> succ 6
7
it :: (Enum a, Num a) => a
Prelude> succ 7
8
it :: (Enum a, Num a) => a
Prelude> pred 9
8
it :: (Enum a, Num a) => a
Prelude> pred 8
7
it :: (Enum a, Num a) => a
Prelude> sin (pi / 2)
1.0
it :: Floating a => a
Prelude> truncate pi
3
it :: Integral b => b
Prelude> round 3.5
4
it :: Integral b => b
Prelude> round 3.4
3
it :: Integral b => b
Prelude> floor 3.7
3
it :: Integral b => b
Prelude> ceiling 3.3
4
it :: Integral b => b
```

2. From `ghci`, type `:?` to print some help. Define a variable, such as `x = 1`, then type `:show bindings`. What do you see?

```haskell
Prelude> x = 1
x :: Num p => p
Prelude> :show bindings
it :: Integral b => b = _
$trModule :: GHC.Types.Module = _
x :: Num p => p = _
```

3. The `words` function counts the number of words in a string. Modify the `wc.hs` example to count the number of words in a file.

```haskell
main = interact linesCount
  where linesCount input = length (lines input)
```

4. Modify the `wc.hs` example again, to print the number of characters in a file.

Version of program that prints lines, words and charaacters counts.
```haskell
main = interact wordCount
  where
      wordCount input = "Lines: " ++ (lines' input)
                              ++ ", words: " ++ (words' input)
                              ++ ", characters: " ++ (chars' input) ++ "\n"
      lines' text = show (length (lines text))
      words' text = show (length (words text))
      chars' text = show (length text)
```
